package services

import (
	"encoding/json"
	"github.com/jfrog/jfrog-client-go/auth"
	"github.com/jfrog/jfrog-client-go/http/jfroghttpclient"
	"github.com/jfrog/jfrog-client-go/utils"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/log"
	"net/http"
)

type EventService struct {
	client     *jfroghttpclient.JfrogHttpClient
	XscDetails auth.ServiceDetails
}

func NewEventService(client *jfroghttpclient.JfrogHttpClient) *EventService {
	return &EventService{client: client}
}

// GetXscDetails returns the Xsc details
func (vs *EventService) GetXscDetails() auth.ServiceDetails {
	return vs.XscDetails
}

// PostEvent sends general event to Xsc and returns msi generated by Xsc.
func (vs *EventService) PostEvent(event XscGeneralEvent) (string, error) {
	httpDetails := vs.XscDetails.CreateHttpClientDetails()
	requestContent, err := json.Marshal(event)
	if err != nil {
		return "", errorutils.CheckError(err)
	}
	resp, body, err := vs.client.SendPost(vs.XscDetails.GetUrl()+"api/v1/event", requestContent, &httpDetails)
	if err != nil {
		return "", err
	}
	if err = errorutils.CheckResponseStatus(resp, http.StatusCreated); err != nil {
		return "", errorutils.CheckError(errorutils.GenerateResponseError(resp.Status, utils.IndentJson(body)))
	}
	var response XscGeneralEventResponse
	err = json.Unmarshal(body, &response)
	return response.MultiScanId, errorutils.CheckError(err)
}

type XscGeneralEvent struct {
	EventType              int    `json:"event_type,omitempty"`
	EventStatus            string `json:"event_status,omitempty"`
	Product                string `json:"product,omitempty"`
	ProductVersion         string `json:"product_version,omitempty"`
	TotalFindings          int    `json:"total_findings,omitempty"`
	TotalIgnoredFindings   int    `json:"total_ignored_findings,omitempty"`
	IsDefaultConfig        bool   `json:"is_default_config,omitempty"`
	JfrogUser              string `json:"jfrog_user,omitempty"`
	OsPlatform             string `json:"os_platform,omitempty"`
	OsArchitecture         string `json:"os_architecture,omitempty"`
	MachineId              string `json:"machine_id,omitempty"`
	AnalyzerManagerVersion string `json:"analyzer_manager_version,omitempty"`
	JpdVersion             string `json:"jpd_version,omitempty"`
	TotalScanDuration      string `json:"total_scan_duration,omitempty"`
	FrogbotSourceMsi       string `json:"frogbot_source_msi,omitempty"`
	FrogbotScanType        string `json:"frogbot_scan_type,omitempty"`
	FrogbotCiProvider      string `json:"frogbot_ci_provider,omitempty"`
}

type XscGeneralEventResponse struct {
	MultiScanId string `json:"multi_scan_id,omitempty"`
}

// TODO should we validate? or if xsc changes its values we need to updated here everytime? what are the mandatory fields?
func (e XscGeneralEvent) IsValidateEvent(event XscGeneralEvent) bool {
	valid := true
	if _, ok := eventTypes[e.EventType]; !ok {
		valid = false
		log.Error("invalid event type in xsc general event request.")
	}
	return valid
}

var eventTypes = map[int]string{
	1: "ShiftLeftScanEvent",
	2: "ScaScanEvent",
	3: "ContextualExpEvent",
	4: "SecretsExpEvent",
	5: "IacExpEvent",
	6: "SastExpEvent",
	7: "ApplicationsExpEvent",
	8: "SourceCodeScanEvent",
}
